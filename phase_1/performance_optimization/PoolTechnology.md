# 池化技术

## 什么是池化技术

    	池化技术 (Pool) 是一种很常见的编程技巧，在请求量大时能明显优化应用性能，降低系统频繁建连的资源开销。
    我们日常工作中常见的有数据库连接池、线程池、对象池等，它们的特点都是将 “昂贵的”、“费时的” 的资源维护在一个特定的 “池子” 中，规定其最小连接数、最大连接数、阻塞队列等配置，方便进行统一管理和复用，通常还会附带一些探活机制、强制回收、监控一类的配套功能。
    	由于在实际应用当做，分配内存、创建进程、线程都会设计到一些系统调用，系统调用需要导致程序从用户态切换到内核态，是非常耗时的操作。因此，当程序中需要频繁的进行内存申请释放，进程、线程创建销毁等操作时，通常会使用内存池、进程池、线程池技术来提升程序的性能。对连接或线程的复用，并对复用的数量、时间等进行控制，从而使得系统的性能和资源消耗达到最优状态。
    	把一些能够复用的东西（比如说数据库连接、线程）放到池中，避免重复创建、销毁的开销，从而极大提高性能。在开发过程中我们会用到很多的连接池，像是数据库连接池、HTTP 连接池、Redis 连接池等等。而连接池的管理是连接池设计的核心。

---

## 常见池化技术原理与作用

### 线程池

```
原理：
1.判断线程池里的核心线程是否都在执行任务
	当提交一个新任务到线程池时，线程池判断corePoolSize线程池是否都在执行任务，如果有空闲线程，则从核心线程池中取一个线程来执行任务，直到当前线程数等于corePoolSize;
2.线程池判断工作队列是否已满
	如果当前线程数为corePoolSize，继续提交的任务被保存到阻塞队列中，等待被执行;
3.判断线程池里的线程是否都处于工作状态
	如果阻塞队列满了，那就创建新的线程执行当前任务，直到线程池中的线程数达到maxPoolSize，这时再有任务来，由饱和策略来处理提交的任务。  
作用：
	线程池技术就是线程的重用技术，使用之前创建好的线程来执行当前任务，并提供了针对线程周期开销和资源冲突问题的解决方案。在系统资源比较紧张的情况下，线程池是保证程序稳定运行的一个有效的解决方案。
	1.减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务。
	2.可以根据系统的承受能力，调整线程池中工作线线程的数目，防止因为消耗过多的内存，而把服务器累趴下。
```



### 对象池

```
原理与作用：
	核心有两点：缓存和共享，即对于那些被频繁使用的对象，在使用完后，不立即将它们释放，而是将它们缓存起来，以供后续的应用程序重 复使用，从而减少创建对象和释放对象的次数，进而改善应用程序的性能。事实上，由于对象池技术将对象限制在一定的数量，也有效地减少了应用程序内存上的开销。
```



### 数据库连接池

```
原理：
	为数据库连接建立一个“缓冲池”，预先在池中放入一定数量的数据库连接管道，需要时，从池子中取出管道进行使用，操作完毕后，在将管道放入池子中，从而避免了频繁的向数据库申请资源，释放资源带来的性能损耗。在如今的分布式系统当中，系统的QPS瓶颈往往就在数据库，所以理解数据库连接池底层构造原理与设计思想是很有益处的。我们常用的数据库连接池有C3P0，DBCP，Druid等。
作用：
	1.资源重用
	2.更快的系统响应速度
	3.心得内存分配手段
	4.统一的连接管理，避免数据库连接的泄露
```



### HttpClient连接池

```
原理：
	连接池中连接都是在发起请求的时候建立，并且都是长连接。连接池释放连接的时候，并不会直接对TCP连接的状态有任何改变，只是维护了两个Set，leased和avaliabled，leased代表被占用的连接集合，avaliabled代表可用的连接的集合，释放连接的时候仅仅是将连接从leased中remove掉了，并把连接放到avaliabled集合中。
作用：
	连接池的连接资源重用策略，避免了频繁创建、释放连接引起的大量性能开销，增加了系统运行的平稳性。
	连接池统一连接管理策略，避免连接资源泄漏或者大量连接资源创建导致内存溢出。
```



---

## 常见线程池介绍与核心配置与调整思路

- newCachedThreadPool：创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。线程池为无限大，当执行第二个任务时第一个任务已经完成，会复用执行第一个任务的线程，而不用每次新建线程。
- newFixedThreadPool：创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。定长线程池的大小最好根据系统资源进行设置。
- newSingleThreadExecutor：创建一个定长线程池，支持定时及周期性任务执行。比Timer更安全，功能更强大。
- newScheduledThreadPool：创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。结果依次输出，相当于顺序执行各个任务。

| 属性 | 缺省值 | 说明 |
| ---- | ------ | ---- |
| corePoolSize |   ......     |   核心线程数<br />\* 核心线程会一直存活，及时没有任务需要执行<br />* 当线程数小于核心线程数时，即使有线程空闲，线程池也会优先创建新线程处理<br />* 设置allowCoreThreadTimeout=true（默认false）时，核心线程会超时关闭   |
| queueCapacity |  | 任务队列容量（阻塞队列）<br />\* 当核心线程数达到最大时，新任务会放在队列中排队等待执行 |
| maxPoolSize |  | 最大线程数<br />\* 当线程数>=corePoolSize，且任务队列已满时。线程池会创建新线程来处理任务<br />* 当线程数=maxPoolSize，且任务队列已满时，线程池会拒绝处理任务而抛出异常 |
| keepAliveTime |  | 线程空闲时间<br />\* 当线程空闲时间达到keepAliveTime时，线程会退出，直到线程数量=corePoolSize<br />\* 如果allowCoreThreadTimeout=true，则会直到线程数量=0 |
| allowCoreThreadTimeout |  | 允许核心线程超时 |
| rejectedExecutionHandler |  | 任务拒绝处理器<br />* 当线程数已经达到maxPoolSize，切队列已满，会拒绝新任务<br />* 当线程池被调用shutdown()后，会等待线程池里的任务执行完毕，再shutdown。如果在调用shutdown()和线程池真正shutdown之间提交任务，会拒绝新任务 |
|  |  |  |



---

## 线程池状态切换流程与异常状态分析

```
1、新建状态（New）：新创建了一个线程对象。
2、就绪状态（Runnable）：线程对象创建后，其他线程调用了该对象的start()方法。该状态的线程位于可运行线程池中，变得可运行，等待获取CPU的使用权。
3、运行状态（Running）：就绪状态的线程获取了CPU，执行程序代码。
4、阻塞状态（Blocked）：阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。阻塞的情况分三种：
（一）、等待阻塞：运行的线程执行wait()方法，JVM会把该线程放入等待池中。(wait会释放持有的锁)
（二）、同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池中。
（三）、其他阻塞：运行的线程执行sleep()或join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。（注意,sleep是不会释放持有的锁）
5、死亡状态（Dead）：线程执行完了或者因异常退出了run()方法，该线程结束生命周期。
```

![](https://mmbiz.qpic.cn/mmbiz_png/yqdSticVI7RPCVS6vlbkLYNyryfvobaaRiap6piaQRvYd6fUkeichUktFeuIcc9WJ0spNcgIORXia7odBicgLq2Lx7UA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

---

## HttpClient连接池核心配置项与调整思路

| 属性 | 缺省值 | 说明 |
| ---- | ------ | ---- |
| maxTotal |   ......     |   最大连接数   |
| defaultMaxPerRoute |  | 默认的每个路由的最大连接数 |
| maxPerRoute |  | 置到某个路由的最大连接数，会覆盖defaultMaxPerRoute |
| connectTimeout |  | 连接超时时间 |
| socketTimeout |  | 读超时时间（等待数据超时时间） |
| connectionRequestTimeout |  | 从池中获取连接超时时间 |
| staleConnectionCheckEnabled |  | 检查是否为陈旧的连接，默认为true，类似testOnBorrow |
| tcpNoDelay |  | 是否立即发送数据，设置为true会关闭Socket缓冲，默认为false |
| soReuseAddress |  | 是否可以在一个进程关闭Socket后，即使它还没有释放端口，其它进程还可以立即重用端口 |
| soTimeout |  | 接收数据的等待超时时间，单位ms |
| soLinger |  | 关闭Socket时，要么发送完所有数据，要么等待60s后，就关闭连接，此时socket.close()是阻塞的 |
| soKeepAlive |  | 开启监视TCP连接是否有效 |
|  |  |  |

---

## 常用数据库连接池比较

|                  | dbcp                                                         | c3p0                                                         | proxool                                      |
| :--------------: | ------------------------------------------------------------ | ------------------------------------------------------------ | -------------------------------------------- |
|       开源       | 是                                                           | 是                                                           | 是                                           |
|   最大连接设置   | 有                                                           | 有                                                           | 有                                           |
|   最小连接设置   | 有                                                           | 有                                                           | 有                                           |
| 连接等待时间设置 | 有                                                           | 有                                                           | 有                                           |
|    连接池监控    | 不提供                                                       | 不提供                                                       | 提供                                         |
|       优点       | 持续运行的稳定性还是可以，不过速度稍慢，在大并发量的压力下稳定性有所下降 | 持续运行的稳定性相当不错，在大并发量的压力下稳定性也有一定保证 | 持续运行的稳定性有一定问题，偶尔出现异常退出 |
|                  |                                                              |                                                              |                                              |



---

## DAL核心配置项与调整思路

#### 参考资料

- [DAL-代码示例](http://wiki.17usoft.com/pages/viewpage.action?pageId=28638391)
- [DAL-相关配置](http://wiki.17usoft.com/pages/viewpage.action?pageId=41262467)


#### 核心配置项与配置思路

| 属性 | 缺省值 | 说明 |
| ---- | ------ | ---- |
| initialSize |   1    |   初始化时建立物理连接的个数。初始化发生在显示调用init方法，或者第一次getConnection时，最终以dba配置的为准......   |
| maxActive | 100 | 最大连接池数量，最终以dba配置的为准 |
| minIdle | 1 | 最小连接池数量，最终以dba配置的为准 |
| maxWait | 3000 | 获取连接时最大等待时间，单位：毫秒 |
| testOnBorrow | false | 申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能 |
| testOnReturn | false | 归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能 |
| testWhileIdle | true | 建议配置为true，不影响性能，并且保证安全性。申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，检测连接是否有效 |
| timeBetweenEvictionRunsMillis | 60000 | 检测空闲连接的间隔时间，单位：毫秒 |
| minEvictableIdleTimeMillis | 180000 | 连接保持空闲而不被驱逐的最长时间，单位：毫秒 |
| checkSqlWhereCondition | true | 在delete和update的sql语句检查是否包含where条件 |
|  |  |  |
|  |  |  |
|  |  |  |

---

